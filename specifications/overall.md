# MIXML Pedagogical Python Quarto Notebook – Master Plan

## Overall Objective and Instructions

Create a Python Quarto book that **teaches and implements** mixfix parsing in a tiny, untyped, applicative ML‑style language called **MIXML**. The notebook must:

- Begin with an immediate, runnable demo ("wow factor")
- Build every component—from lexer to evaluator—in small, comprehensible increments
- Highlight ambiguities and their resolution via operator precedence/associativity
- Remain < 1000 LOC of library code so students can read it end‑to‑end in one sitting
- Provide hidden pretty-printing functions that provide concise symbolic representations of data structures.

Use the PDFs in the 'references' folder as technical references on mixfix operator parsing.

## Structure/Flow

| Section  | Section Title                                                           | Section Objectives/Key Points                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| -------- | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 0        | Motivation: why use syntactic sugar when you can use a mixfix operator? | Motivate mixfix operators by:<br />- A real world example: Agda language.<br />- Our approach to capture key features: introducing (full) MIXML, with small example programs. A key example at the end is                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 1        | Theory: mixfix operators and their anatomy                              | - The subset of Unicode that we can use for operator parts -- a detour through Unicode classes.<br />- THe theory of 'mixfix' operators -- see `operators.md` for more info.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 2        | Strategy: supplementing the expression grammar as we go                 | Provide strategy on how to implement mixfix operators in MIXML, assuming that we would know how to implement a "MIXML-CORE" without mixfix operators.<br />– Begin with a core language without any mixfix operators -- i.e. functions to be applied are in the head of expression lists.<br />- IDEA: When we parse an expression, we check mixfix operators in scope, and generate an "augmented" CFG.<br />– Requirements for parsing when using dynamically-augmented grammars lead to our parser implementation: (a) parser combinators so we can manipulate parsers in real-time, and (b) dealing with left-recursion without grammar rewriting by memoization, (c) when ambiguous, provide "all options" for parses.<br />– A "demixfixing" step translates mixfix operator applications back to , and thus back to the core language. |
| 3        | Specification and implementation of MIXML-CORE                          | Straightforward implementation of a MIXML-CORE parser and interpreter.<br />– Implement lexer - we can reuse it.<br />– Introduce a compact parser combinator library that uses a memoizing approach to backtrack from potential left recursion.<br />– *Optional section that reader can expand: MIXML-CORE evaluator.*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 4        | Step 1: converting operators in scope to a CFG                          | – Handling all properties (arity fixity etc.)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 5        | Step 2: converting a CFG to a parser; augmenting the MIXML parser       | - Show how we can error on ambiguous cases helpfully, by showing all possible parses                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 6        | Step 3: "demixfixing" from MIXML to MIXML-CORE                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 7        | Putting it all together                                                 | - Actually evaluate key examples of MIXML introduced at start                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 8        | Extensions                                                              | Some other features make working with mixfix operators considerably nicer in "real world languages". Introduce them, and sketch out their implementation (when possible.)<br />- Partial ordering-based precedence resolution.<br />- Pattern matching.<br />- Sections.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Appendix | GNU Free Documentation License                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |

---

## 3  Structure/Flow

> **Guiding Principle**  Readers repeatedly *see* a concept, *code* it, and *test* it before moving on.

| Step | Section Title                         | Pedagogical Aim                                                | Transition Rationale                                     | **Aspect of MIXML + Implementation Introduced**                    |
| ---- | ------------------------------------- | -------------------------------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------------------- |
| 0    | Preamble & Quick Demo                 | Hook interest with a runnable MIXML snippet producing a result | Capitalise on curiosity before diving into mechanics     | Running MIXML code via**bootstrap parser & evaluator**              |
| 1    | Tokenisation Fundamentals             | Distinguish identifiers, Unicode operator symbols, numerals    | Lexical categories are prerequisite for parsing rules    | **MIXML lexer skeleton**; `Token` classes; Unicode support        |
| 2    | Baseline Expression Grammar           | Parse variables, application,`let`, and lambdas (no mixfix)  | Establish core AST before adding operator complexity     | **AST nodes**; always‑recursive `let`; environment basics        |
| 3    | Mixfix Declaration Syntax             | Parse underscore‑hole patterns & build operator table         | Shows how syntax like `_×_` maps to arity/fixity data | **OperatorTable**; underscore split; arity derivation               |
| 4    | Ambiguous Operator Sequences          | Parse sequences without precedence → produce forest           | Makes ambiguity concrete; motivates precedence rules     | **Ambiguous AST node**; simple sequence parser                      |
| 5    | Precedence & Associativity Resolution | Implement precedence‑climbing / Pratt algorithm               | Resolves forest into tree or raises `AmbiguityError`   | **Resolver** using operator table; tests with `_×_`, `_+_`     |
| 6    | Pattern‑Matching Expressions         | Introduce `match … with` syntax & evaluation                | Required for `if_then_else_` implementation            | **Pattern AST**; evaluator pattern‑match logic                     |
| 7    | Mixfix Inside Patterns                | Allow operators in pattern position (`x :: xs`)            | Demonstrates same mixfix rules apply in patterns         | **Pattern parser extension**; shared operator table                 |
| 8    | Evaluator for MIXML                   | Implement interpreter with closures, ints, bools, symbols      | Completes language runtime; enables full examples        | **eval()**; built‑ins (`_×_`, `_+_`, `_²`) as Python funcs |
| 9    | Pretty‑Printing & REPL Helpers       | Provide `pretty()` for AST & values; minimal REPL loop       | Improves UX; aids debugging & demonstration clarity      | **pretty()**; colorised Unicode output                              |
| 10   | Demo/Implementation Reconciliation    | Swap out bootstrap, validate equivalence, celebrate            | Confirms student code correctness; ends learning arc     | **assert\_equivalent\_asts**; set `USING_DEMO = False`            |

---

## 3  Quick‑Demo Implementation Plan (“hidden setup cell” strategy)

1. **Bootstrap module**  Ship`mixfix_demo.py` (≤1000 LOC) exposing`Operator`,`parse`,`pretty`,`AmbiguityError`,`eval`.
2. **Hidden *****init***** cell**  First cell (collapsed via Quarto metadata) runs:
   ```python
   import importlib, sys, types, pathlib
   USING_DEMO = True
   sys.path.insert(0, str(pathlib.Path().resolve()))  # ensure we see mixfix_demo.py
   from mixfix_demo import *
   ```
3. **Wow‑factor demo**  Immediately evaluate:
   ```python
   fact = parse_and_eval("""
       let fact n = if_then_else_ (n == 0) 1 (_×_ n (fact (_- n 1)))
       fact 5
   """)
   print(fact)  # ⇒ 120
   ```
4. **Handoff**  At notebook end, after the student re‑implements everything, run:
   ```python
   assert_equivalent_asts(parse, student_parse)
   USING_DEMO = False
   ```
   Subsequent runs use the freshly implemented parser.
